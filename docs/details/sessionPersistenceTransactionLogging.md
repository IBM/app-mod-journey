# Session Persistence and Transaction Logging

 - Applications running on WebSphereND may already be configured to use Session Persistence and Transaction Logging
 - WebSphereND managed the in-memory case out of the box
 - The migration plan in Transformation Advisor will indicate if any aspect of your application's configuration has not been automatically configured
 
## Configuring application Database Session Persistence
 - In WebSphereND, the Application Server session management is configured to store session data in a database 
 - In the migration artifacts generated by Transformation Advisor, the session database information will be automatically collected in the server.xml file, and the Database Session Persistence feature (sessionDatabase-1.0) is enabled. 
 - The following is the partial of the server.xml file generated by Transformation Advisor
```
     ...
     <feature>sessionDatabase-1.0</feature>
    </featureManager>

    <authData 
        id="domains1CellManager01/session" 
        password="${domains1CellManager01_session_password}" 
        user="${domains1CellManager01_session_user}"/>

    <dataSource 
        beginTranForResultSetScrollingAPIs="false" 
        beginTranForVendorAPIs="false" 
        containerAuthDataRef="domains1CellManager01/session" 
        id="DB2 Universal JDBC Driver DataSource_taStaticCluster_DataSource_1683733967481" 
        jdbcDriverRef="DB2_Universal_JDBC_Driver_Provider_taStaticCluster_JDBCProvider_1661355825734" 
        jndiName="jdbc/Sessions" 
        type="javax.sql.ConnectionPoolDataSource">
        
        <properties.db2.jcc 
            databaseName="${DB2_Universal_JDBC_Driver_DataSource_taStaticCluster_DataSource_1683733967481_databaseName_1}" 
            driverType="4" 
            portNumber="${DB2_Universal_JDBC_Driver_DataSource_taStaticCluster_DataSource_1683733967481_portNumber_1}" 
            retrieveMessagesFromServerOnGetMessage="true" 
            serverName="${DB2_Universal_JDBC_Driver_DataSource_taStaticCluster_DataSource_1683733967481_serverName_1}"/>
        <connectionManager connectionTimeout="180" enableContainerAuthForDirectLookups="true" maxPoolSize="10"/>
        <heritageSettings helperClass="com.ibm.websphere.rsadapter.DB2UniversalDataStoreHelper" replaceExceptions="true"/>
    </dataSource>

    <httpSessionDatabase 
        dataSourceRef="DB2 Universal JDBC Driver DataSource_taStaticCluster_DataSource_1683733967481" 
        scheduleInvalidationFirstHour="14" 
        scheduleInvalidationSecondHour="2" 
        writeFrequency="TIME_BASED_WRITE" 
        writeInterval="10s" 
        tableName="SESSIONS" />
```
 - It will use the same database that the application used prior to being modernized
 - If the session database table name is not "sessions",  you need to specify it in the httpSessionDatabase element
 - Before deployment, you need to update the session database's username and password in the secret.yaml file
 - Further information and configuration assistance can be found [here](https://openliberty.io/docs/latest/create-session-table.html)

## Configuring application in-memory Session Persistence 
 - In WebSphereND, the Application Server session management is configured to store session data in a data grid
 - This will not be automatically configured by Transformation Advisor
 - In Liberty Container, it uses JCache instead of local in-memory caches for a standardized distributed in-memory caching API.  Liberty runtime handles the session caching in the web container layer.
 - Here are the steps to config your container to an Infinispan service deployed on OpenShift in client-server mode:
 1.  Deploy the Infinispan service in OpenShift Container Platform  
 2.  Add the following lines in the Containerfile in the migration artifacts to install the Infinispan Client
```
...
# Instruct configure.sh to use Infinispan for session caching.
# This should be set to the Infinispan service name.
# TIP - Run the following oc/kubectl command with admin permissions to determine this value:
#       oc get infinispan -o jsonpath={.items[0].metadata.name}
ENV INFINISPAN_SERVICE_NAME=example-infinispan

# Uncomment and set to override auto detected values.
# These are normally not needed if running in a Kubernetes environment.
# One such scenario would be when the Infinispan and Liberty deployments are in different namespaces/projects.
#ENV INFINISPAN_HOST=
#ENV INFINISPAN_PORT=
#ENV INFINISPAN_USER=
#ENV INFINISPAN_PASS=

RUN features.sh
...
```
 3.  Build the Liberty container image
 4.  Modify the application-cr.yaml file to mount Infinispan secret to the container
```
...
    spec:
      volumes:
        - name: infinispan-secret-volume
          secret:
            secretName: example-infinispan-generated-secret
      volumeMounts:
        - name: infinispan-secret-volume
          readOnly: true
          mountPath: "/platform/bindings/infinispan/secret"
...
```    
 5. Deploy your application to OpenShift
 - Information on how best to configure this can be found [here](https://openliberty.io/docs/latest/distributed-session-caching.html)


## Configuring application to store Transaction Log in database
- The transaction service will be automatically enabled by Transformation Advisor in server.xml file
- The datasource reference is specified in the transaction element
```
    <transaction 
        dataSourceRef="translog" 
        heuristicRetryWait="0" 
        propogatedOrBMTTranLifetimeTimeout="300" 
        recoverOnStartup="true" 
        recoveryGroup="modresortsx2.ear-peer-group" 
        recoveryIdentity="${env.HOSTNAME}${wlp.server.name}"/>
```
- Make sure the jdbc-4.1 feature is enabled in the featureManager element
- You need to manually add the datasource for the transaction database log in the server.xml file, modify the database access information to point to the transaction database that the application used prior to being modernized
```
    <dataSource id="translog"  transactional="false">
      <jdbcDriver libraryRef="DB2JCC4LIB"/>
      <properties.db2.jcc currentSchema="CBIVP"
          databaseName="SAMPLE" driverType="4"
          portNumber="50000" serverName="localhost"
          user="db2admin" password="{xor}Oz1tPjsyNjE=" />
    </dataSource>
```
- Further information and configuration assistance can be found [here](https://openliberty.io/docs/latest/transaction-service.html)

## Configuring application to store Transaction Log in file
- The transaction service will be automatically enabled by Transformation Advisor in server.xml file
- You can modify the setting used for the transaction manager
```
<transaction 
        heuristicRetryWait="0" 
        propogatedOrBMTTranLifetimeTimeout="300" 
        recoverOnStartup="true" 
        recoveryGroup="DayTrader EE7.ear-peer-group" 
        recoveryIdentity="${env.HOSTNAME}${wlp.server.name}" 
        transactionLogDirectory="/tranlogs/${env.HOSTNAME}${wlp.server.name}"/>
```

- The transaction service is configured with the recoveryGroup and recoveryIdentity attributes continually monitors its peers, which are other server instances that are configured with the same recoveryGroup value.
- To monitor peers, servers must be configured so that their transaction logs are accessible to all members of the recovery group. A server that performs peer recovery must have access to the same set of transactional resources as the server that is being recovered.
- This transaction service requires the use of a shared file system to host the transaction logs, such as an NFSv4-mounted network-attached storage (NAS) or a storage area network (SAN).
- Need to modify the application-cr.yaml file to create a mount point to the /translogs directory 
- Alternatively, you can configure the transaction service to use an existing database as a shared repository for the transaction logs.
- For more information about the attributes for transaction, see [Transaction Manager](https://openliberty.io/docs/latest/reference/config/transaction.html)
